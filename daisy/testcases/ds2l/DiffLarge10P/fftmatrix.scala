import daisy.lang._
import Real._
import daisy.lang.Vector._

object fftmatrix {

	def fftmatrix(m: Matrix): Matrix = {
require(m >= -326.68 && m <= 677.57 && m.size(512,2)
	 && m.specM(Set((Set((58, 1)),(-213.17, 536.36)), (Set((4, 0)),(49.36, 660.55)),
		(Set((56, 1), (45, 1)),(436.68, 620.2)), (Set((441, 1), (270, 0), (19, 0), (456, 1)),(-137.42, 555.38)),
		(Set((402, 0), (164, 0)),(68.19, 323.59)), (Set((380, 0), (151, 0), (509, 1), (392, 1), (7, 1)),(-250.67, 315.88)),
		(Set((472, 0), (87, 0), (494, 0), (459, 0)),(-232.04, 11.95)), (Set((221, 0), (243, 0), (141, 1), (364, 0), (498, 0)),(-238.52, 606.12)),
		(Set((326, 1), (99, 1), (88, 1), (471, 1), (209, 1), (330, 1), (114, 1)),(44.39, 447.18)), (Set((194, 0), (183, 0)),(-188.83, 250.86)),
		(Set((170, 0), (53, 0)),(-268.63, 523.42)), (Set((433, 1), (182, 1), (262, 0), (314, 1), (292, 1), (251, 0), (327, 1)),(289.63, 552.09)),
		(Set((316, 1), (76, 1), (372, 0)),(68.58, 325.81)), (Set((65, 1), (121, 0), (132, 0), (387, 0), (15, 0)),(-82.43, 419.86)),
		(Set((133, 1), (224, 0), (254, 1), (213, 0)),(-137.81, -86.09)), (Set((334, 0), (3, 1), (14, 1), (490, 0), (148, 1), (455, 0), (83, 0)),(80.65, 534.76)),
		(Set((239, 0), (360, 0), (349, 0), (122, 0), (201, 1), (333, 1), (478, 1), (467, 1)),(-315.91, -154.32)), (Set((216, 1), (307, 0), (296, 0), (417, 0)),(-163.95, -52.7)),
		(Set((155, 0), (231, 1), (456, 0), (60, 0), (163, 1), (284, 1), (57, 1), (44, 1)),(-279.61, 618.13)), (Set((33, 1)),(44.42, 392.32)),
		(Set((509, 0), (178, 1), (485, 0), (189, 1), (323, 1), (258, 0)),(-87.31, 67.17)), (Set((310, 1), (72, 1), (7, 0)),(-260.01, 127.67)),
		(Set((444, 1), (152, 0), (193, 1), (394, 0), (380, 1), (75, 0), (209, 0), (196, 0)),(161.07, 360.47)), (Set((330, 0)),(-276.82, -116.36)),
		(Set((341, 0), (406, 1), (486, 0), (10, 1), (356, 0), (459, 1), (63, 1)),(134.79, 573.69)), (Set((208, 1), (342, 1), (288, 0)),(-295.61, -66.37)),
		(Set((318, 1), (329, 1), (409, 0), (91, 1), (37, 0), (182, 0), (223, 1)),(627.06, 666.93)), (Set((212, 1), (292, 0)),(-154.21, 291.95)),
		(Set((314, 0)),(-21.11, 560.73)), (Set((448, 0), (41, 0), (25, 1), (170, 1), (280, 1), (64, 1)),(-33.43, 312.54)),
		(Set((29, 1), (109, 0)),(-255.2, 352.48)), (Set((185, 1), (174, 1)),(125.25, 302.96)),
		(Set((265, 0), (3, 0), (375, 0), (148, 0), (135, 0), (372, 1), (132, 1)),(29.36, 259.61)), (Set((504, 1), (493, 1), (333, 0), (26, 1), (322, 0)),(-125.2, 307.15)),
		(Set((478, 0), (71, 0)),(277.96, 397.53)), (Set((82, 0), (387, 1), (227, 0)),(-204.77, 579.59)),
		(Set((147, 1), (443, 0), (97, 0), (231, 0), (94, 1)),(171.85, 309.94)), (Set((70, 1), (59, 1), (295, 0), (481, 1)),(-15.61, 99.08)),
		(Set((33, 0), (470, 1), (167, 0), (189, 0)),(-17.95, -0.76)), (Set((178, 0), (219, 1), (416, 0), (165, 0)),(-52.76, 565.07)),
		(Set((154, 0), (444, 0), (420, 0), (193, 0)),(-260.81, 333.64)), (Set((497, 0), (155, 1), (166, 1), (177, 1), (311, 1), (432, 1), (406, 0), (10, 0)),(-133.64, 94.37)),
		(Set((131, 0)),(597.01, 675.27)), (Set((234, 1), (390, 1), (63, 0)),(311.79, 426.53)),
		(Set((500, 1), (128, 1), (208, 0), (249, 1), (238, 1), (22, 1), (340, 0), (439, 0)),(375.53, 638.69)), (Set((78, 0), (89, 0), (212, 0), (264, 1)),(-254.55, 504.93)),
		(Set((93, 0), (196, 1), (352, 1)),(402.72, 653.26)), (Set((473, 1), (66, 1), (25, 0), (397, 0), (211, 1), (90, 1), (356, 1), (291, 0)),(-312.51, 321.3)),
		(Set((412, 0), (423, 0), (40, 0)),(-163.39, 37.92)), (Set((174, 0), (161, 0), (306, 0), (158, 1), (17, 1)),(-274.49, 475.47)),
		(Set((28, 1), (504, 0), (173, 1), (363, 0), (385, 0)),(-227.31, 444.0))))
	)
/* m: (real part of signal / Fourier coeff., imaginary part of signal / Fourier coeff. ) */
        if (m.numRows() == 1)
            m
        else {
            val scalar: Real = 1
            val Pi: Real = 3.1415926
            val n: Int = m.numRows()   /* signal length, has to be power of 2 */
            val direction: Vector = Vector(List(0.0, -2.0))
            val evens: Matrix = fftmatrix(m.everyNth(2, 0))
            val odds: Matrix = fftmatrix(m.everyNth(2, 1))

            val resleft: Matrix = evens.enumRowsMap((k:Int, x:Vector) => {
                //val (k, x) = y
                val base: Vector = x / scalar
                val offset: Vector = (direction.*(Pi * k / n)).exp() x odds.row(k) / scalar // here vector multiplication should be specialy defined for complex numbers? is it the same as cross product of vectors?
                base + offset
            })
            val resright: Matrix = evens.enumRowsMap((k:Int, x:Vector)  => {
                //val (k, x) = y
                val base: Vector = x / scalar
                val offset: Vector = (direction.*(Pi * k / n)).exp() x odds.row(k) / scalar // here vector multiplication should be specialy defined for complex numbers?
                base - offset
            })

            resleft ++ resright
        }
    }


}